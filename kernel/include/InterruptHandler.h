#ifndef INTERRUPTHANDLER_H
#define INTERRUPTHANDLER_H

#include <stdint.h>

/**
    Transfer to here from assembly.

    @param edi General purpose register value.
    @param esi General purpose register value.
    @param ebp General purpose register value.
    @param esp General purpose register value.
    @param ebx General purpose register value.
    @param edx General purpose register value.
    @param ecx General purpose register value.
    @param eax General purpose register value.
    @param irr Interrupt number.
    @param err Error code.
    @param eip Instruction address at the time of the interrupt.
    @param cs Code segment at the time of the interrupt.
    @param eflags eflags register value at the time of the interrupt.
    @param esp_int Stack pointer at the time of the interrupt.
    @param ss Stack segment at the time of the interrupt.

    @return Syscalls need to return a value in eax. That goes here.
 */
extern "C"
uint32_t interrupt_handler(uint32_t edi,
                       uint32_t esi,
                       uint32_t ebp,
                       uint32_t esp,
                       uint32_t ebx,
                       uint32_t edx,
                       uint32_t ecx,
                       uint32_t eax,
                       uint32_t irr,
                       uint32_t err,
                       uint32_t eip,
                       uint16_t cs,
                       uint32_t eflags,
                       uint32_t esp_int,
                       uint16_t ss);

/**
    Information on the identites of various interrupts.
 */
enum class InterruptNumber : uint8_t {
    // Invalid operation code
    inv_op = 0x06,
    // General protection fault
    gpf = 0x0D,
    // Page fault
    page_fault = 0x0E,
    // First PIC1 interrupt
    pic1_start = 0x20,
    // Last PIC1 interrupt
    pic1_end = 0x27,
    // First PIC2 interrupt
    pic2_start = 0x28,
    // Last PIC2 interrupt
    pic2_end = 0x2F,
    // Programmable interval timer
    pit = 0x20,
    // PS/2 Keyboard
    ps2_keyboard = 0x21,
    // Serial port 2
    com2 = 0x23,
    // Serial port 1
    com1 = 0x24,
    // LPT2 (parallel)
    lpt2 = 0x25,
    // Floppy drive
    floppy = 0x26,
    // LPT1 (printer) or spurious
    lpt1 = 0x27,
    // CMOS real time clock
    rtc = 0x28,
    // Advanced configuration and power interface
    acpi = 0x29,
    // Peripherals
    peri2 = 0x2A,
    // Peripherals
    peri1 = 0x2B,
    // PS/2 Mouse
    ps2_mouse = 0x2C,
    // Coprocessor
    coproc = 0x2D,
    // Primary ATA
    ata1 = 0x2E,
    // Secondary ATA or spurious
    ata2 = 0x2F,
    // System call interrupt number
    syscall = 0x80
};

/**
    Stores the contents of the 8 general purpose registers.
 */
class InterruptRegisters {
public:
    /**
        Initialises with the values of each register given.

        @param edi Contents of the edi register.
        @param esi Contents of the esi register.
        @param ebp Contents of the ebp register.
        @param esp Contents of the esp register.
        @param ebx Contents of the ebx register.
        @param edx Contents of the edx register.
        @param ecx Contents of the ecx register.
        @param eax Contents of the eax register.
     */
    InterruptRegisters(uint32_t edi,
                       uint32_t esi,
                       uint32_t ebp,
                       uint32_t esp,
                       uint32_t ebx,
                       uint32_t edx,
                       uint32_t ecx,
                       uint32_t eax)
        : edi_val{edi},
          esi_val{esi},
          ebp_val{ebp},
          esp_val{esp},
          ebx_val{ebx},
          edx_val{edx},
          ecx_val{ecx},
          eax_val{eax}
    {}

    /**
        Initialises with the values in an array.

        @param regs Contents of the 8 registers in the order edi, esi, ebp, esp,
                    ebx, edx, ecx, eax, as generated by a pushad in assembly.
     */
    explicit InterruptRegisters(uint32_t regs[8]) :
        edi_val{regs[0]},
        esi_val{regs[1]},
        ebp_val{regs[2]},
        esp_val{regs[3]},
        ebx_val{regs[4]},
        edx_val{regs[5]},
        ecx_val{regs[6]},
        eax_val{regs[7]}
    {}

    /**
        We provide a defualt constructor that sets registers to zero. Useful
        for creating processes, when we don't care what the values are.
     */
    InterruptRegisters() :
        edi_val{0},
        esi_val{0},
        ebp_val{0},
        esp_val{0}, 
        ebx_val{0},
        edx_val{0},
        ecx_val{0},
        eax_val{0}
    {}

    /**
        Get the edi value.

        @return Value of edi register just before the interrupt.
     */
    uint32_t edi() const { return edi_val; }

    /**
        Set the stored edi value.

        @param val Value to store.
     */
    void set_edi(uint32_t val) { edi_val = val; }

    /**
        Get the esi value.

        @return Value of esi register just before the interrupt.
     */
    uint32_t esi() const { return esi_val; }

    /**
        Set the stored esi value.

        @param val Value to store.
     */
    void set_esi(uint32_t val) { esi_val = val; }

    /**
        Get the ebp value.

        @return Value of ebp register just before the interrupt.
     */
    uint32_t ebp() const { return ebp_val; }

    /**
        Set the stored ebp value.

        @param val Value to store.
     */
    void set_ebp(uint32_t val) { ebp_val = val; }

    /**
        Get the esp value. This, in general, will be the esp value after the
        interrupt, rather than before.

        @return Value of esp register just after the interrupt.
     */
    uint32_t esp() const { return esp_val; }

    /**
        Set the stored esp value.

        @param val Value to store.
     */
    void set_esp(uint32_t val) { esp_val = val; }

    /**
        Get the ebx value.

        @return Value of ebx register just before the interrupt.
     */
    uint32_t ebx() const { return ebx_val; }

    /**
        Set the stored ebx value.

        @param val Value to store.
     */
    void set_ebx(uint32_t val) { ebx_val = val; }

    /**
        Get the edx value.

        @return Value of edx register just before the interrupt.
     */
    uint32_t edx() const { return edx_val; }

    /**
        Set the stored edx value.

        @param val Value to store.
     */
    void set_edx(uint32_t val) { edx_val = val; }

    /**
        Get the ecx value.

        @return Value of ecx register just before the interrupt.
     */
    uint32_t ecx() const { return ecx_val; }

    /**
        Set the stored ecx value.

        @param val Value to store.
     */
    void set_ecx(uint32_t val) { ecx_val = val; }

    /**
        Get the eax value.

        @return Value of eax register just before the interrupt.
     */
    uint32_t eax() const{ return eax_val; }

    /**
        Set the stored eax value.

        @param val Value to store.
     */
    void set_eax(uint32_t val) { eax_val = val; }

private:
    uint32_t edi_val;
    uint32_t esi_val;
    uint32_t ebp_val;
    uint32_t esp_val;
    uint32_t ebx_val;
    uint32_t edx_val;
    uint32_t ecx_val;
    uint32_t eax_val;
};

/**
    Stores the stack state of an interrupt.
 */
class InterruptStack {
public:
    /**
        Initialises with each of the values given seperately.

        @param code The error code.
        @param eip Address in the eip register.
        @param cs Code segment.
        @param eflags Contents of the eflags register.
        @param esp Contents of the stack pointer register.
        @param ss Satck segment.
     */
    InterruptStack(uint32_t code, uint32_t eip, uint16_t cs, uint32_t eflags,
        uint32_t esp, uint16_t ss) :
        code_val{code},
        eip_val{eip},
        cs_val{cs},
        eflags_val{eflags},
        esp_val{esp},
        ss_val{ss}
    {}

    /**
        Initialises with values given in an array.

        @param stack Contents of the stack in the order code, eip, cs, eflags,
               esp, ss.
     */
    explicit InterruptStack(uint32_t stack[6]) :
        code_val{stack[0]},
        eip_val{stack[1]},
        cs_val{static_cast<uint16_t>(stack[2])},
        eflags_val{stack[3]},
        esp_val{stack[4]},
        ss_val{static_cast<uint16_t>(stack[5])}
    {}

    /**
        We provide a defualt constructor that sets registers to zero. Useful
        for creating processes, when we don't care what some of the values are.
     */
    InterruptStack() :
        code_val{0},
        eip_val{0},
        cs_val{0},
        eflags_val{0},
        esp_val{0},
        ss_val{0}
    {}

    /**
        Get the error code.

        @return Interrupt error code.
     */
    uint32_t code() const { return code_val; }

    /**
        Get the contents of the eip register.

        @return Value of eip register just before the interrupt.
     */
    uint32_t eip() const { return eip_val; }

    /**
        Set the contents of the eip register. Should probably only be used when
        creating new processes.

        @param val Value to set the register to.
     */
    void set_eip(uint32_t val) { eip_val = val; }

    /**
        Get the contents of the code segment register.

        @return Value of cs register just before the interrupt.
     */
    uint16_t cs() const { return cs_val; }

    /**
        Set the contents of the cs register. Should probably only be used when
        creating new processes.

        @param val Value to set the register to.
     */
    void set_cs(uint16_t val) { cs_val = val; }

    /**
        Get the contents of the eflags register.

        @return Value of eflags register just before the interrupt.
     */
    uint32_t eflags() const { return eflags_val; }

    /**
        Set the contents of the eflags register. Should probably only be used
        when creating new processes.

        @param val Value to set the register to.
     */
    void set_eflags(uint32_t val) { eflags_val = val; }

    /**
        Get the contents of the eflags register.

        @return Value of esp register just before the interrupt.
     */
    uint32_t esp() const { return esp_val; }

    /**
        Set the contents of the esp register. Should probably only be used when
        creating new processes.

        @param val Value to set the register to.
     */
    void set_esp(uint32_t val) { esp_val = val; }

    /**
        Get the contents of the stack segment register.

        @return Value of ss register just before the interrupt.
     */
    uint16_t ss() const { return ss_val; }

    /**
        Set the contents of the ss register. Should probably only be used when
        creating new processes.

        @param val Value to set the register to.
     */
    void set_ss(uint16_t val) { ss_val = val; }

private:
    uint32_t code_val;
    uint32_t eip_val;
    uint16_t cs_val;
    uint32_t eflags_val;
    uint32_t esp_val;
    uint16_t ss_val;
};

/**
    Base interrupt handler. Abstract.
 */
class InterruptHandler {
public:
    /**
        Provide the system state information.

        @param regs Registers at the time of the interrupt.
        @param stack Stack at the time of the interrupt.
        @param no Interrupt number.
     */
    InterruptHandler(InterruptRegisters& regs, InterruptStack& stack,
                     InterruptNumber no)
        : ir{regs}, is{stack}, inum{no}
    {}

    /**
        Handler routine. Overload to provide specific handling.
     */
    virtual void handle() = 0;

protected:
    // Register contents
    InterruptRegisters& ir;
    // Stack contents
    InterruptStack& is;
    // Interrupt number
    InterruptNumber inum;
};

/**
    Default interrupt handler. Does nothing except clearing PIC status.
 */
class DefaultHandler : public InterruptHandler {
public:
    // Inherit base constructor
    using InterruptHandler::InterruptHandler;

    /**
        Handler routine. Sends a PIC acknowledgement if necessary. Checks for
        a spurious PIC interrupt.
     */
    virtual void handle() override;
};

/**
    Interrupt handler for the Programmable Interval Timer.
 */
class PitHandler : public DefaultHandler {
public:
    // Inherit base constructor
    using DefaultHandler::DefaultHandler;

    /**
        Handler routine. Increases the system tick count.
     */
    virtual void handle() override;
};

/**
    Interrupt handler for the PS/2 keyboard.
 */
class Ps2KeyboardHandler : public DefaultHandler {
public:
    // Inherit base constructor
    using DefaultHandler::DefaultHandler;

    /**
        Handler routine. Processes the scan code and sends to the output device.
     */
    virtual void handle() override;
};

/**
    Interrupt handler for the syscall interface.
 */
class SysCallHandler : public InterruptHandler {
public:
    // Inherit base constructor
    using InterruptHandler::InterruptHandler;

    /**
        Handler routine. Create an error message and panic.
     */
    virtual void handle() override;
};

/**
    Interrupt handler for an invalid opcode. Causes a kernel panic.
 */
class InvOpHandler : public InterruptHandler {
public:
    // Inherit base constructor
    using InterruptHandler::InterruptHandler;

    /**
        Handler routine. Create an error message and panic.
     */
    virtual void handle() override;
};

/**
    Interrupt handler for a general protection fault. Causes a kernel panic.
 */
class GpfHandler : public InterruptHandler {
public:
    // Inherit base constructor
    using InterruptHandler::InterruptHandler;

    /**
        Handler routine. Create an error message and panic.
     */
    virtual void handle() override;
};

/**
    Interrupt handler for a page fault. Prints out the details and causes a
    kernel panic.
 */
class PageFaultHandler : public InterruptHandler {
public:
    // Inherit base constructor
    using InterruptHandler::InterruptHandler;

    /**
        Handler routine. Create an error message and panic.
     */
    virtual void handle() override;
};

#endif
