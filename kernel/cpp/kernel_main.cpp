#include <cstdio>
#include <typeinfo>

#include "Kernel.h"
#include "Logger.h"
#include "ProcTable.h"
//#include "RttiTest.h"
#include "Scheduler.h"

// Just for compilation testing remove when ready.
// #include <klib_ostream.h>
// #include <klib_sstream.h>
// #include <klib_typeinfo.h>

// Exception testing.
/*struct FakeException {};
struct DerivedException : public klib::exception {
    DerivedException() { klib::printf("Constructing derived exception\n"); }
    ~DerivedException() { klib::printf("Destructing derived exception\n"); } 
};

struct DummyObject {
    DummyObject() { klib::printf("Constructing dummy object\n"); }
    ~DummyObject() { klib::printf("Destructing dummy object\n"); }
};

void raise()
{
    DummyObject d;
    throw DerivedException {};
}

void try_but_dont_catch()
{
    try
    {
        klib::printf("try block that won't throw.\n");
    }
    catch (FakeException&)
    {
        klib::printf("Caught with the wrong catch.\n");
    }

    try
    {
        raise();
    }
    catch (FakeException&)
    {
        klib::printf("Caught a FakeException.\n");
    }
    catch (DerivedException& e)
    {
        klib::printf("Caught a Derived Exception, rethrowing.\n");
        throw e;
    }

    klib::printf("try_but_dont_catch handled exception.\n");
}

void catchit()
{
    try
    {
        try_but_dont_catch();
    }
    catch (klib::exception& e)
    {
        klib::printf("Caught a klib::exception.\n");
        klib::printf("what: %s\n", e.what());
        klib::printf("catchit handled exception.\n");
    }
    catch (...)
    {
        klib::printf("Caught a generic exception.\n");
        klib::printf("catchit handled exception.\n");
    }
}

void seppuku()
{
    catchit();
}*/

/**
    Main kernel routine, entered from assembly. Creates a new Kernel instance.

    @param kvs Virtual memory address of the start of the kernel.
    @param kve Virtual memory address of the end of the kernel.
    @param kps Physical memory address of the end of the kernel.
    @param kpe Physical memory address of the end of the kernel.
    @param pdt The basic Page Descriptor Table set up in the loader.
    @param tpt Location reserved for a temporary page table.
    @param mbp Start of Multiboot information, generated by GRUB.
 */
extern "C"
void kernel_main (void* kvs,
                  void* kve,
                  void* kps,
                  void* kpe,
                  void* pdt,
                  void* tpt,
                  void* mbp)
{
    // Make new kernel.
    Kernel k {kvs, kve, kps, kpe, pdt, tpt, mbp};

    // Try setting up the first multiboot modules as a user mode process and
    // running it.
/*    if (k.get_multiboot().mods(0).valid())
    {
        const MultiBootModule& m = k.get_multiboot().mods(0);
        k.syslog()->info("Creating process info from module at %p\n", m.mod_start());
        Process* p = new Process {m.mod_start(), *k.get_pdt(), 1};
        k.default_disable();
        k.syslog()->info("Launching process.\n");
        p->launch();
        delete p;
        k.syslog()->error("Returned from process.\n");
    }
    else
        k.syslog()->error("First mulitboot module is invalid\n");*/

//    rtti_test();

    // Tell the scheduler to start the process with the init_pid as defined in
    // ProcTable.h
    k.get_scheduler().start(init_pid);

    // Enter the kernel loop.
    k.loop();

    // If we've got here, something has gone wrong.
    k.panic("Returning from kernel_main");

    // I don't know what could possibly have happened for us to get here. If we
    // have, we will return to assembly and enter an infinite loop.
}
