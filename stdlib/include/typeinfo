#ifndef TYPEINFO_H
#define TYPEINFO_H

// Use std as the default namespace.
#ifndef NMSP
#define NMSP std
#endif /* NMSP */

#include "../include/cstring"
#include "../include/exception"

// Forward declarations.
namespace __cxxabiv1 {
    class __class_type_info;
} // end __cxxabiv1 namespace

#ifndef HOSTED_TEST /* Clash with the compiler version when hosted. */

namespace std { // Has to be in std. Compiler magic is involved.

/**
    This type provides the information necessary to compare two types for
    equality and the name of the type.
 */
class type_info {
public:
    /**
        The virtual destructor goes first. Apparently the ordering has some
        magic interaction with the compiler when creating the vtable.
     */
    virtual ~type_info();

    /**
        Default construction is deleted.
     */
    type_info() = delete;

    /**
        Copy construction is deleted.

        @param other Other type_info to (not) copy.
     */
    explicit type_info(const type_info& other) = delete;

    /**
        Copy assignment is deleted.

        @param other Other type_info to (not) copy.
        @return This type_info.
     */
    type_info& operator=(const type_info& other) = delete;

    /**
        Gets the name of the type. This name is generated by the compiler. It
        probably has name mangling. For GCC, a leading * is ignored.

        @return Null terminated C string with the type name.
     */
    const char* name() const
    {
        return (n[0] == '*' ? n + 1 : n);
    }

    /**
        Compares two types for equality. It might be possible to simply compare
        the address, or we might have to compare the contents of the names. I
        haven't really worked it out, so we'll do both.

        @param other Other type to compare with.
        @return True if the types are the same, false otherwise.
     */
    bool operator==(const type_info& other) const
    {
        return ((n == other.n) || (NMSP::strcmp(n, other.n) == 0));
    }

    /**
        Compares two types for non-equality. Uses operator==.

        @param other Other type to compare with.
        @return True if the types are different, false otherwise.
     */
    bool operator!=(const type_info& other) const
    {
        return !(*this == other);
    }

    /**
        Returns true if this type precedes the other type in this
        implementations collation order. This could change between runs of the
        same program. Base the ordering on the name, since we don't care much
        about performance.

        @param other Other type to compare with.
        @return True if this type is first, false otherwise.
     */
    bool before(const type_info& other) const
    {
        return (NMSP::strcmp(n, other.n) < 0);
    }

    /**
        Returns a value that must be the same for two type_infos for the same
        type. It can be the same for different types, although that's
        discouraged. The value itself may change between runs of the same
        program. The simplest option is just to use the (first four chars of
        the) name.

        @return A value that will be the same for all type_infos for the same
                type.
     */
    size_t hash_code() const
    {   
        return reinterpret_cast<size_t>(n);
    }

    /**
        Try to catch a thrown type.

        @param throw_type Type of the thrown object.
        @param throw_obj Pointer to the thrown object.
        @param outer Number of outer pointers.
        @return Whether the thrown type can be upcast to this type.
     */
    virtual bool __do_catch(const type_info* throw_type, void** throw_obj,
        size_t outer) const;

    /**
        Used during catch matching.

        @param target Type to convert to.
        @param obj_ptr Pointer to the object to convert.
     */
    virtual bool __do_upcast(const __cxxabiv1::__class_type_info* target,
        void** obj_ptr) const;

    /**
        Test if this is a function type.

        @return True if this type info is for any kind of function, false
                otherwise.
     */
    virtual bool __is_function_p() const;

    /**
        Test if this is a pointer type.

        @return True if this type info is for any kind of pointer, false
                otherwise.
     */
    virtual bool __is_pointer_p() const;
protected:
    // Stores the name of the type.
    const char* n;

    // Construct from a name.
    explicit type_info(const char* name) : n { name} {}
};

} // end std namespace

#else /* HOSTED_TEST, we need the compiler type_info. */
#include <typeinfo>
#endif /* HOSTED_TEST */

namespace NMSP {

/**
    Exception thrown when typeid is used on a dereferenced null pointer of a
    polymorphic type.
 */
class bad_typeid : public exception {
public:
    /**
        Default constructor.
     */
    bad_typeid() noexcept {}

    /**
        Virtual destructor.
     */
    virtual ~bad_typeid() noexcept;

    /**
        Gives an explanatory string.

        @return String describing this exception.
     */
    const char* what() const noexcept;
};

/**
    Exception thrown when a dynamic cast fails its run time checks.
 */
class bad_cast : public exception {
public:
    /**
        Default constructor.
     */
    bad_cast() noexcept {}

    /**
        Virtual destructor.
     */
    virtual ~bad_cast() noexcept;

    /**
        Gives an explanatory string.

        @return String describing this exception.
     */
    const char* what() const noexcept;
};

} // end NMSP namespace

#endif /* TYPEINFO_H */
