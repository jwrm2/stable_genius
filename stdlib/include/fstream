#ifndef FSTREAM_H
#define FSTREAM_H

// Use std as the default namespace.
#ifndef NMSP
#define NMSP std
#endif /* NMSP */

#include <algorithm>
#include <cstdio>
#include <ios>
#include <istream>
#include <ostream>
#include <streambuf>
#include <string>

#ifndef KLIB
#include <fcntl.h>
#include <initialise.h>
#include <unistd.h>
#endif /* KLIB not defined */

namespace NMSP {

/**
    This class implements stream style interactions with a file as the
    associated character sequence. In the kernel, file operations are provided
    by classes derived from File (eg. BlockFile, DiskFile) and this buffer
    stores a pointer to an open File object, to which calls are forwarded. In
    user space, FILE is a wrapper around this buffer, the buffer stores a file
    descriptor and calls are system calls.
 */
template <typename CharT, typename Traits = char_traits<CharT>>
class basic_filebuf : public basic_streambuf<CharT, Traits> {
public:
    /** Type of the character. */
    using char_type = CharT;
    /** Type of the traits. traits_type::char_type must equal char_type. */
    using traits_type = Traits;
    /** Type of an int that can represent the char. Taken from traits_type. */
    using int_type = typename traits_type::int_type;
    /** Type that can represent a position in a stream. Taken from
        traits_type. Must be fpos::<traits_type::state_type>. */
    using pos_type = typename traits_type::pos_type;
    /** Type of an int that can represent an offset in a stream. Taken from
        traits_type. */
    using off_type = typename traits_type::off_type;
protected:
    /** Type of the instantiated template parent, just for convenience. */
    using streambuf_type = basic_streambuf<char_type, traits_type>;
public:

    /**
        Default constructor. Initialises the base class, but does not associate
        with a file.
     */
    basic_filebuf() :
        streambuf_type {},
        isopen {false},
        reading {false},
        writing {false},
#ifdef KLIB
        open_file {nullptr},
#else /* KLIB defined */
        fd {-1},
#endif /* KLIB defined */
        buffered {true}
    {
    }

    /**
        The copy constructor is deleted.

        @param other basic_filebuf to (not) copy from.
     */
    basic_filebuf(const basic_filebuf& other) = delete;

    /**
        Move constructor. Pirates the buffers and associated file from the
        other stream. The other stream is left in a closed state and its
        buffers are set to null, although the file itself is not affected.

        @param other basic_filebuf to pirate.
     */
    basic_filebuf(basic_filebuf&& other) :
        streambuf_type {other},
        isopen {other.isopen},
        reading {other.reading},
        writing {other.writing},
#ifdef KLIB
        open_file {other.open_file},
#else /* KLIB defined */
        fd {other.fd},
#endif /* KLIB defined */
        buffered {true}
    {
        other.isopen = false;
#ifdef KLIB
        other.open_file = nullptr;
#else /* KLIB defined */
        other.fd = -1;
#endif /* KLIB defined */
        other.setg(nullptr, nullptr, nullptr);
        other.setp(nullptr, nullptr, nullptr);
    }

    /**
        Copy assignment is deleted.

        @param other basic_filebuf to (not) copy from.
     */
    basic_filebuf& operator=(const basic_filebuf& other) = delete;

    /**
        Move assignemnt. Closes the currently associated file. Then pirates the
        buffers and associated file from the other stream. The other stream is 
        left in a closed state and its buffers
        are set to null, although the file itself is not affected.

        @param other basic_filebuf to pirate.
     */
    basic_filebuf& operator=(basic_filebuf&& other)
    {
        close();

        streambuf_type::operator=(other);
        isopen = other.isopen;
        reading = other.reading;
        writing = other.writing;
#ifdef KLIB
        open_file = other.open_file;
#else /* KLIB defined */
        fd = other.fd;
#endif /* KLIB defined */
        buffered = other.buffered;

        other.isopen = false;
#ifdef KLIB
        other.open_file = nullptr;
#else /* KLIB defined */
        other.fd = -1;
#endif /* KLIB defined */
        other.setg(nullptr, nullptr, nullptr);
        other.setp(nullptr, nullptr, nullptr);

        return *this;
    }

    /**
        Swaps the contents of two basic_filebufs.

        @param other basic_filebuf to swap with.
     */
    void swap(basic_filebuf& other)
    {
        streambuf_type::swap(other);
        NMSP::swap(isopen, other.isopen);
        NMSP::swap(reading, other.reading);
        NMSP::swap(writing, other.writing);
#ifdef KLIB
        NMSP::swap(open_file, other.open_file);
#else /* KLIB defined */
        NMSP::swap(fd, other.fd);
#endif /* KLIB defined */
        NMSP::swap(buffered, other.buffered);
    }

    /**
        Destructor. Calls close to possibly flush, free the memory of the
        buffers and set is_open to false.
     */
    ~basic_filebuf() { close(); }

    /**
        Tests whether there is an open file associated with the buffer, that is
        whether the last call to open() succeeded and there hasn't been a call
        to close() since then.

        @return Whether there is an open file associated.
     */
    bool is_open() const { return isopen; }

    /**
        Opens the file with the specified name, with the specified mode, by
        forwarding the call to fopen(). Does nothing if there is already an
        associated file. Allocates memory for the read and/or write internal
        buffers, depending on the open mode, but does not fill the read buffer.

        @param s Null terminated C-string containing the file name.
        @param str String containing the file name.
        @param m The mode to open the file in, a combination of
               ios_base::openmode members.
        @return this on success, nullptr on failure.
     */
    basic_filebuf* open(const char* s, ios_base::openmode m)
    {
        string c_mode;
        basic_filebuf* ret_val = open_impl_pre(m, c_mode);
        if (ret_val == nullptr)
            return nullptr;

        // Forward the call to open the file.
#ifdef KLIB
        open_file = NMSP::fopen(s, c_mode.c_str());
        if (open_file == nullptr)
            return nullptr;
        isopen = true;
#else /* KLIB defined */
        int flags = 0;
        if (reading && writing)
            flags |= O_RDWR;
        else if (reading)
            flags |= O_RDONLY;
        else if (writing)
            flags |= O_WRONLY;
        else
            return nullptr;
        if (append)
            flags |= O_APPEND;  
        // TODO mode doesn't do anything yet.
        fd = ::open(s, flags, 0);
        if (fd == -1)
            return nullptr;
#endif /* KLIB defined */

        ret_val = open_impl_post(m);
        if (ret_val == nullptr)
            return nullptr;

        return this;
    }

    basic_filebuf* open(const string& s, ios_base::openmode m)
    {
        return open(s.c_str(), m);
    }

    /**
        Closes the associated file. Flushes the output buffer, if the file was
        open for writing, then frees the memory for internal buffers, before
        forwarding the call to fclose(). Does nothing if the file is already
        closed.

        @return This basic_filebuf on success, nullptr on failure.
     */
    basic_filebuf* close()
    {
        // Check whether there is an associated buffer to close.
        if (!isopen)
            return nullptr;

        // Flush the output.
        int_type ret_val1 = 0;
        if (writing)
            ret_val1 = overflow();

        // Close the file.
#ifdef KLIB
        int ret_val2 = open_file->close();
        delete open_file;
#else /* KLIB defined */
        int ret_val2 = ::close(fd);
#endif /* KLIB defined */
        isopen = false;

        // Free buffers.
        if (streambuf_type::eback() != nullptr && buffered)
        {
            delete[] streambuf_type::eback();
            streambuf_type::setg(nullptr, nullptr, nullptr);
        }
        else if (streambuf_type::pbase() != nullptr && buffered)
        {
            delete[] streambuf_type::pbase();
            streambuf_type::setp(nullptr, nullptr, nullptr);
        }

        if (!traits_type::eq_int_type(ret_val1, traits_type::eof()) && 
            ret_val2 == 0)
            return this;
        return nullptr;
    }

    /**
        Override sputc() from streambuf. This is only needed when the file is
        open for reading and appending and the last action was an underflow that
        put stuff in the get area that we need to discard.

        @param ch Character to write.
        @return The character written, or eof on failure.
     */
    virtual int_type sputc(char_type ch) override
    {
        if (append && reading && last_underflow)
        {
            streambuf_type::setg(streambuf_type::eback(),
                streambuf_type::eback(), streambuf_type::eback());
            streambuf_type::setp(streambuf_type::pbase(),
                streambuf_type::pbase(), streambuf_type::epptr());
        }
        return streambuf_type::sputc(ch);
    }

protected:
    /** Whether there is currently an associated file. */
    bool isopen;
    /** Whether the file is open for reading. */
    bool reading;
    /** Whether the file is open for writing. */
    bool writing;
    /** Whether we are appending. */
    bool append;
    /** Whether the last action was an underflow. Matters for append. */
    bool last_underflow;
#ifdef KLIB
    /** Pointer to the associated file. */
    FILE* open_file;
#else /* KLIB defined */
    /** File descriptor to use for system calls. */
    int fd;
#endif /* KLIB defined */
    /** Whether this object owens the buffers it's using. */
    bool buffered;

    /**
        If the file is open for reading, gives the number of characters known
        to be available. Subsequent reads will be able to get at least that
        many characters. This implementation indicates the number of characters
        remaining in the current get area. Gives -1 if the file is not open for
        reading or if EoF has been reached. 0 indicates nothing could be
        determined.

        @return The number of characters definitely available for reading. 0 for
                 no information, -1 for no more chartacters.
     */
    virtual streamsize showmanyc() override
    {
        // Do nothing unless the file is open for reading.
        if (isopen && reading)
        {
            // If we have a get area, return the number of characters still in
            // it.
            if (streambuf_type::eback() != nullptr)
                return streambuf_type::egptr() - streambuf_type::gptr();
            // We may be unbuffered: in that case return 0 (unknown).
            else
                return 0;
        }
        // Return -1 if not open or not open for reading.
        return -1;
    }

    /**
        Reads data from the associated file into the get area.

        @return The first character read on success, EoF on failure.
     */
    virtual int_type underflow() override
    {
        // Do nothing unless the file is open for reading.
        if (isopen && reading)
        {
            // Don't bother doing anything if there is still data available.
            if (streambuf_type::gptr() < streambuf_type::egptr())
                return traits_type::to_int_type(*streambuf_type::gptr());

            // If we have a put area, flush the data first.
            if (streambuf_type::pbase() != nullptr &&
                !(reading && append && last_underflow))
                if (traits_type::eq_int_type(overflow(), traits_type::eof()))
                    // Flushing failed. Bail.
                    return traits_type::eof();

            // Overflow may have successfully refilled the buffer, so we might
            // be able to stop here.
            if (streambuf_type::gptr() < streambuf_type::egptr())
                return traits_type::to_int_type(*streambuf_type::gptr());

            // Fill the buffer, if we have one.
            if (streambuf_type::eback() != nullptr)
            {
                // Now read from the actual file.
#ifdef KLIB
                streamsize read_size = open_file->read(streambuf_type::eback(),
                    sizeof(char_type), BUFSIZ);
#else /* KLIB defined */
                streamsize read_size =
                    ::read(fd, streambuf_type::eback(), BUFSIZ);
#endif /* KLIB defined */
                last_underflow = true;

                // Adjust pointers.
                streambuf_type::setg(streambuf_type::eback(),
                    streambuf_type::eback(),
                    streambuf_type::eback() + read_size);
                if (streambuf_type::pbase() != nullptr)
                    streambuf_type::setp(streambuf_type::pbase(),
                        streambuf_type::pbase(),
                        streambuf_type::pbase() + BUFSIZ);

                // Check for failure.
                if (read_size == 0)
                    return traits_type::eof();

                return traits_type::to_int_type(*streambuf_type::gptr());
            }
            // If we don't have a buffer, read a single character.
            else
            {
                char_type c;
#ifdef KLIB
                streamsize read_size = 
                    open_file->read(&c, sizeof(char_type), 1);
#else /* KLIB defined */
                streamsize read_size = ::read(fd, &c, 1);
#endif /* KLIB defined */
                if (read_size == 0)
                    return traits_type::eof();

                return traits_type::to_int_type(c);
            }
        }

        // Failure return if not open for reading.
        return traits_type::eof();
    }

    /**
        Similar to underflow, but advances the get pointer by one. The standard
        seems to indicate that an override of the version from basic_streambuf
        is required, but I don't see why that's necessary.

        @return  The value of the read character on success, EoF on failure.
     */
    using streambuf_type::uflow;

    /**
        Puts a character back in to the get area to be read again. May be the
        same or a different character. May fail if at the start of the file or
        if the file is open for reading only and a different character is being
        put back.

        @param c Character to put back. Defaults to EoF, which means use the
               character that was there already.
        @return EoF on failure. c on success, unless c was EoF, in which some
                character other than EoF.
     */
    virtual int_type pbackfail(int_type c = traits_type::eof()) override
    {
        // Do nothing unless the file is open for reading and we have a buffer.
        if (isopen && reading && streambuf_type::eback() != nullptr)
        {
            // We shouldn't really have called this function if there's space
            // in the get area, but we'll check for it anyway.
            if (streambuf_type::eback() < streambuf_type::gptr())
                gbump(-1);

            // We need to reread the buffer one place back.
            else
            {
                // We need to shift back by one.
                streamoff shift = -1;

                // If we have a put area, flush the data first.
                if (streambuf_type::pbase() != nullptr)
                {
                    // Adjust the shift to account for the move from overflow.
                    shift -= (streambuf_type::egptr() == streambuf_type::eback()
                        ? streambuf_type::pptr() - streambuf_type::pbase() :
                        streambuf_type::egptr() - streambuf_type::eback());

                    if (traits_type::eq_int_type(overflow(),
                        traits_type::eof()))
                        // Flushing failed. Bail.
                        return traits_type::eof();
                }

                // Now move the associated file position back to one before the
                // previous start of the buffer and reread.
#ifdef KLIB
                if (open_file->seek(shift, SEEK_CUR) != 0)
                    // Seek failed. Bail.
                    return traits_type::eof();
#else /* KLIB defined */
                pos_type ret_val {-1};
                if (::llseek(fd, static_cast<int32_t>(shift >> 32),
                    static_cast<int32_t>(shift), &ret_val, SEEK_CUR) != 0)
                    // Seek failed. Bail.
                    return traits_type::eof();
#endif /* KLIB defined */
                if (traits_type::eq_int_type(underflow(), traits_type::eof()))
                    // Failed to refill the buffer. Bail.
                    return traits_type::eof();
            }

            // If we're not changing the character, we're done. If we are, we
            // need to be able to write.
            if (traits_type::eq_int_type(c, traits_type::eof()))
                return traits_type::not_eof(c);
            else if (traits_type::eq_int_type(c,
                traits_type::to_int_type(*streambuf_type::gptr())))
                return c;
            else if (writing)
            {
                *streambuf_type::gptr() = traits_type::to_char_type(c);
                return c;
            }
        }
        return traits_type::eof();
    }

    /**
        Ensures there is space for more writing by flushing the internal buffer
        to the associated file. If a character other than EoF is provided,
        writes that character too.

        @param ch Character to write. EoF indicates don't write a character.
        @return Some character other than EoF on success, EoF on failure.
     */
    virtual int_type overflow(int_type ch = traits_type::eof()) override
    {
        // Do nothing unless the file is open for writing.
        if (writing && isopen)
        {
            // If we're open for reading and appending and the last action was
            // an underflow that put stuff in the get area, we need to discard
            // that stuff rather than writing it to the end of the file.
            if (reading && append && last_underflow)
            {
                streambuf_type::setg(streambuf_type::eback(),
                    streambuf_type::eback(), streambuf_type::eback());
                streambuf_type::setp(streambuf_type::pbase(),
                    streambuf_type::pbase(), streambuf_type::epptr());
                last_underflow = false;
            }

            // Check whether we need to write the character.
            bool to_write = !traits_type::eq_int_type(ch, traits_type::eof());

            // If we have space in the put area, append the character to it.
            if (streambuf_type::pptr() < streambuf_type::epptr() && to_write)
            {
                *streambuf_type::pptr() = traits_type::to_char_type(ch);
                pbump(1);
                to_write = false;
            }

            // Flush the buffer.
            if (streambuf_type::pbase() != nullptr)
            {
                // If we're open for reading and in the middle of the file, we
                // need to move the associated file position back to overwrite.
                if (reading && !append &&
                    streambuf_type::eback() != streambuf_type::egptr())
                {
                    ptrdiff_t shift = streambuf_type::eback() -
                        streambuf_type::egptr();
#ifdef KLIB
                    if (open_file->seek(shift, SEEK_CUR) != 0)
                        // Seek failed. Bail.
                        return traits_type::eof();
#else /* KLIB defined */
                    pos_type ret_val {-1};
                    if (::llseek(fd, 0,
                        static_cast<int32_t>(shift), &ret_val, SEEK_CUR) != 0)
                        // Seek failed. Bail.
                        return traits_type::eof();
#endif /* KLIB defined */
                }

                // Write the buffer, if there is anything in it.
                if (streambuf_type::pptr() - streambuf_type::pbase() != 0)
                {
#ifdef KLIB
                    int_type ret_val = open_file->write(streambuf_type::pbase(),
                        sizeof(char_type),
                        streambuf_type::pptr() - streambuf_type::pbase());
#else /* KLIB defined */
                    int_type ret_val = ::write(fd, streambuf_type::pbase(),
                        sizeof(char_type) *
                        (streambuf_type::pptr() - streambuf_type::pbase()));
#endif /* KLIB defined */
                    last_underflow = false;

                    if (ret_val !=
                        streambuf_type::pptr() - streambuf_type::pbase())
                        return traits_type::eof();
                }

                // No need to flush the write. If the FILE has an internal
                // buffer, it doesn't need to be flushed now.

                // Reset pointers.
                streambuf_type::setp(streambuf_type::pbase(),
                    streambuf_type::pbase(), streambuf_type::pbase() + BUFSIZ);

                // Refill the buffer if we're reading, but not appending, too.
                if (reading && !append && streambuf_type::eback() != nullptr)
                {
                    // This is allowed to fail as we may be at the end of the
                    // file.
#ifdef KLIB
                    streamsize read_size = open_file->read(
                        streambuf_type::eback(), sizeof(char_type), BUFSIZ);
#else /* KLIB defined */
                    streamsize read_size = ::read(fd, streambuf_type::eback(),
                        sizeof(char_type) * BUFSIZ);
#endif /* KLIB defined */
                    last_underflow = true;

                    streambuf_type::setg(streambuf_type::eback(),
                        streambuf_type::eback(),
                        streambuf_type::eback() + read_size);
                }

                // We may still have a character to write. Just put it in the
                // new buffer.
                if (to_write)
                {
                    *streambuf_type::pptr() = traits_type::to_char_type(ch);
                    pbump(1);
                }
            }
            else if (to_write)
            {
                // We're operating in unbuffered mode and we have a character to
                // write. Send it.
                char_type ch2 = traits_type::to_char_type(ch);
#ifdef KLIB
                size_t ret_val = open_file->write(&ch2, sizeof(char_type), 1);
#else /* KLIB defined */
                size_t ret_val = ::write(fd, &ch2, sizeof(char_type));
#endif /* KLIB defined */
                if (ret_val != 1)
                    return traits_type::eof();
            }

            // Success if we've got here.
            return traits_type::not_eof(ch);
        }
        return traits_type::eof();
    }

    /**
        Sets this to an unbuffered stream, or sets the internal buffer to the
        space provided. Only allowed when not associated with a file, has no
        effect otherwise.

        @param s Start of the user provided buffer, or nullptr to indicate
               unbuffered.
        @param n Number of elements available in the buffer, or 0 to indicate
               unbuffered.
        @return This basic_filebuf, as a basic_streambuf pointer.
     */
    virtual streambuf_type* setbuf(char_type* s, streamsize n) override
    {
        // Do nothing if the file is already open.
        if (isopen)
            return this;

        // Set to unbuffered mode.
        if (s == nullptr && n == 0)
        {
            // Deallocate buffer if it exists.
            if (streambuf_type::eback() != nullptr && buffered)
            {
                delete[] streambuf_type::eback();
                streambuf_type::setg(nullptr, nullptr, nullptr);
            }
            else if (streambuf_type::pbase() != nullptr && buffered)
            {
                delete[] streambuf_type::pbase();
                streambuf_type::setp(nullptr, nullptr, nullptr);
            }
        }
        else if (s != nullptr && n > 0)
        {
            // Replace current buffer.
            if (streambuf_type::eback() != nullptr && buffered)
                delete[] streambuf_type::eback();
            
            else if (streambuf_type::pbase() != nullptr && buffered)
                delete[] streambuf_type::pbase();

            if (reading)
                streambuf_type::setg(s, s, s + n);

            if (writing)
                streambuf_type::setp(s, s, s + n);
        }

        // Set buffered to false to indicate the object does not own a buffer.
        buffered = false;
        return this;
    }

    /**
        Repositions the file pointer to the position off from dir.

        @param off Offset from dir to position to.
        @param dir Base position, beg, cur or end.
        @param which Whether to reposition the get or put area. Since these are
               shared for basic_filebuf, this is ignored.
        @return The new absolute position in the file on success, or -1 on
                failure.
     */
    virtual pos_type seekoff(off_type off, ios_base::seekdir dir,
        ios_base::openmode) override
    {
        // Don't do anything if the file is not open.
        if (!isopen)
            return pos_type {-1};

        // If we have a put area, flush the data first. This also means we don't
        // have to worry about saving a high water mark, as the buffer is always
        // flushed on a move.
        if (streambuf_type::pbase() != nullptr &&
            !(reading && append && last_underflow))
            if (traits_type::eq_int_type(overflow(), traits_type::eof()))
                // Flushing failed. Bail.
                return pos_type {-1};

        // Call fseek to do the shift.
        int ret_val = -1;
        pos_type ret_pos {-1};
        switch (dir)
        {
        case ios_base::beg:
#ifdef KLIB
            ret_val = open_file->seek(off, SEEK_SET);
#else /* KLIB defined */
            ret_val = ::llseek(fd, static_cast<int32_t>(off >> 32),
                static_cast<int32_t>(off), &ret_pos, SEEK_SET);
#endif /* KLIB defined */
            break;
        case ios_base::cur:
            // If the file is open for reading, we need to move the offset back
            // by the unread buffer size, to account for having already read
            // from the file.
            if (reading && streambuf_type::eback() != nullptr)
                off -= (streambuf_type::egptr() - streambuf_type::gptr());
#ifdef KLIB
            ret_val = open_file->seek(off, SEEK_CUR);
#else /* KLIB defined */
            ret_val = ::llseek(fd, static_cast<int32_t>(off >> 32),
                static_cast<int32_t>(off), &ret_pos, SEEK_CUR);
#endif /* KLIB defined */
            break;
        case ios_base::end:
#ifdef KLIB
            ret_val = open_file->seek(off, SEEK_END);
#else /* KLIB defined */
            ret_val = ::llseek(fd, static_cast<int32_t>(off >> 32),
                static_cast<int32_t>(off), &ret_pos, SEEK_END);
#endif /* KLIB defined */
            break;
        }
        if (ret_val != 0)
            return pos_type {-1};

        // Set the buffers to empty.
        if (streambuf_type::eback() != nullptr)
            streambuf_type::setg(streambuf_type::eback(),
                streambuf_type::eback(), streambuf_type::eback());
        if (streambuf_type::pbase() != nullptr)
            streambuf_type::setp(streambuf_type::pbase(),
                streambuf_type::pbase(), streambuf_type::pbase() + BUFSIZ);

        // Get the current position, for returning.
        pos_type fpos_ret {-1};
        // fpos_ret is a pos_type (fpos<traits_type::state_type>), whereas
        // fgetpos needs a fpos_t* (C-style) type. Within klib, these are the
        // same (see the forward declarations in cstdio.h), but for a
        // HOSTED_TEST, fpos_t is defined by the system library. We'll just
        // assume we can convert, which isn't very portable, but should work
        // with glibc.
#ifdef KLIB
        ret_val = open_file->getpos(reinterpret_cast<fpos_t*>(&fpos_ret));
#else /* KLIB defined */
        ret_val = ::llseek(fd, 0, 0, &fpos_ret, SEEK_CUR);
#endif /* KLIB defined */
        if (ret_val != 0)
            return pos_type {-1};
        return fpos_ret;
    }

    /**
        Repositions the file pointer to the absolute position specified. Calls
        seekoff with dir set as the beginning.

        @param sp Position to set.
        @param which Whether to reposition the get or put area. Since these are
               shared for basic_filebuf, this is ignored.
        @return The new absolute position in the file on success, or -1 on
                failure.
     */
    virtual pos_type seekpos(pos_type sp,
        ios_base::openmode which = ios_base::in | ios_base::out) override
    {
        return seekoff(off_type{sp}, ios_base::beg, which);
    }

    /**
        Resynchronises the buffer with the underlying file. If the put area is
        active, calls overflow to write the data. If the get area is active,
        discard it, move the file position back and reread it.

        @return 0 on success, -1 on failure.
     */
    virtual int sync() override
    {
        // Save the curent offset.
        off_type off {-1};
        if (reading)
            off = streambuf_type::gptr() - streambuf_type::eback();

        // If we have a put area, flush the data first.
        if (streambuf_type::pbase() != nullptr &&
            !(reading && append && last_underflow))
            if (traits_type::eq_int_type(overflow(), traits_type::eof()))
                // Flushing failed. Bail.
                return -1;

        int ret_val;
#ifdef KLIB
        ret_val = open_file->flush();
        if (ret_val != 0)
            // Underlying flush failed. Bail.
            return -1;
#endif /* KLIB defined */

        // Reread the get area. The overflow probably did this already, but
        // we've flushed the associated file since then.
        if (reading)
        {
            // Move the position back.
            ptrdiff_t shift = streambuf_type::eback() - streambuf_type::egptr();
#ifdef KLIB
            ret_val = open_file->seek(shift, SEEK_CUR);
#else /* KLIB defined */
            pos_type ret_pos {-1};
            ret_val = ::llseek(fd, 0,
                    static_cast<int32_t>(shift), &ret_pos, SEEK_CUR);
#endif /* KLIB defined */
            if (ret_val != 0)
                // Seek failed. Bail.
                return -1;

            // Reread buffer.
#ifdef KLIB
            streamsize read_size = open_file->read(streambuf_type::eback(),
                sizeof(char_type), BUFSIZ);
#else /* KLIB defined */
            streamsize read_size = ::read(fd, streambuf_type::eback(),
                sizeof(char_type) * BUFSIZ);
#endif /* KLIB defined */

            // Adjust pointers.
            streambuf_type::setg(streambuf_type::eback(),
                streambuf_type::eback() + min(off, read_size),
                streambuf_type::eback() + read_size);
            if (streambuf_type::pbase() != nullptr)
                streambuf_type::setp(streambuf_type::pbase(),
                    streambuf_type::gptr(),
                    streambuf_type::pbase() + BUFSIZ);
        }

        // Success if we've reached here.
        return 0;
    }

    /**
        Changes the associated locale.
        TODO skipping locale stuff for now.

        @param loc New locale to set.
     */
    // virtual void imbue(const locale& loc) override;


    /**
        Calls the parent gbump() to advance the get pointer. If we're also open
        for writing, keeps the put pointer in step.

        @param count Number of characters to advance the next pointer by.
     */
    virtual void gbump(int count) override
    {
        streambuf_type::gbump(count);
        if (writing && streambuf_type::pbase() != nullptr)
            streambuf_type::setp(streambuf_type::pbase(),
                streambuf_type::gptr(), streambuf_type::epptr());
    }

    /**
        Calls the parent pbump() to advance the put pointer. If we're also open
        for reading, keeps the get pointer in step.

        @param count Number of characters to advance the next pointer by.
     */
    virtual void pbump(int count) override
    {
        streambuf_type::pbump(count);
        if (reading && streambuf_type::eback() != streambuf_type::egptr())
            streambuf_type::setg(streambuf_type::eback(),
                streambuf_type::pptr(), streambuf_type::egptr());
    }

    /**
        Override xsputn() from streambuf. This is only needed when the file is
        open for reading and appending and the last action was an underflow that
        put stuff in the get area that we need to discard.

        @param s Buffer to get the characters from.
        @param count Number of characters to write.
        @return The number of characters write. Will equal count on success.
                Will be less than count if eof was reached.
     */
    virtual streamsize xsputn(const char_type* s, streamsize count)
    {
        if (append && reading && last_underflow)
        {
            streambuf_type::setg(streambuf_type::eback(),
                streambuf_type::eback(), streambuf_type::eback());
            streambuf_type::setp(streambuf_type::pbase(),
                streambuf_type::pbase(), streambuf_type::epptr());
        }
        return streambuf_type::xsputn(s, count);
    }

#ifndef KLIB
    /**
        Non-standard open on an existing file descriptor. Doesn't make system
        calls for opening, but does set up a buffer, Does nothing if there is
        already an associated file. Allocates memory for the read and/or write
        internal buffers, depending on the open mode, but does not fill the read
        buffer.

        @param f Existing file descriptor to open.
        @param m The mode to open the file in, a combination of
               ios_base::openmode members.
        @return this on success, nullptr on failure.
     */
    basic_filebuf* open(int f, ios_base::openmode m)
    {
        string c_mode;
        basic_filebuf* ret_val = open_impl_pre(m, c_mode);
        if (ret_val == nullptr)
            return nullptr;

        // TODO find some way to check if an fd is open or not?
        if (f == -1)
            return nullptr;

        // The file is already open, we just need to set the file descriptor.
        fd = f;

        ret_val = open_impl_post(m);
        if (ret_val == nullptr)
            return nullptr;

        return this;
    }
#endif /* KLIB not defined */

    // Utility function to read the C++ openmode. Sets reading, writing and
    // append appropriately, and returns the corresponding C-style mode string,
    // or an empty string if the openmode is bad.
    string read_cxxmode(ios_base::openmode mode)
    {
        string c_mode {""};
        switch(static_cast<size_t>(mode))
        {
        case ios_base::in:
            c_mode = "r";
            reading = true;
            break;
        case ios_base::out: case (ios_base::out | ios_base::trunc):
            c_mode = "w";
            writing = true;
            break;
        case ios_base::app: case (ios_base::app | ios_base::out):
            c_mode = "a";
            writing = true;
            append = true;
            break;
        case (ios_base::in | ios_base::out):
            c_mode = "r+";
            reading = true;
            writing = true;
            break;
        case (ios_base::in | ios_base::out | ios_base::trunc):
            c_mode = "w+";
            reading = true;
            writing = true;
            break;
        case (ios_base::app | ios_base::in):
        case (ios_base::app | ios_base::in | ios_base::out):
            c_mode = "a+";
            reading = true;
            writing = true;
            append = true;
            break;
        case (ios_base::binary | ios_base::in):
            c_mode = "rb";
            reading = true;
            break;
        case (ios_base::binary | ios_base::out):
        case (ios_base::binary | ios_base::out | ios_base::trunc):
            c_mode = "wb";
            writing = true;
            break;
        case (ios_base::app | ios_base::binary):
        case (ios_base::app | ios_base::binary | ios_base::out):
            c_mode = "ab";
            writing = true;
            append = true;
            break;
        case (ios_base::binary | ios_base::in | ios_base::out):
            c_mode = "r+b";
            reading = true;
            writing = true;
            break;
        case (ios_base::binary | ios_base::in | ios_base::out |
            ios_base::trunc):
            c_mode = "w+b";
            reading = true;
            writing = true;
            break;
        case (ios_base::app | ios_base::binary | ios_base::in):
        case (ios_base::app | ios_base::binary | ios_base::in | ios_base::out):
            c_mode = "a+b";
            reading = true;
            writing = true;
            append = true;
            break;
        default:
            break;
        }
        return c_mode;
    }

    // Actions to be carried out on open before opening the file. Returns this
    // on success and nullptr on failure. c_mode is set to the C-style mode
    // equaivalent to m.
    basic_filebuf* open_impl_pre(ios_base::openmode m, string& c_mode)
    {
        // Check whether there is already an associated file.
        if (isopen)
            return nullptr;

        // Reset flags.
        reading = false;
        writing = false;
        append = false;
        last_underflow = false;

        // Get rid of ate bit.
        m &= ~ios_base::ate;

        // Determine the cstdio mode string.
        c_mode = read_cxxmode(m);
        if (c_mode == "")
            return nullptr;

        return this;
    }

    // Actions to be carried out on open after opening the file.
    basic_filebuf* open_impl_post(ios_base::openmode m)
    {
        // If the ate bit is set, attempt to seek to the end of the file.
        bool ate = (m & ios_base::ate);
        if (ate)
        {
#ifdef KLIB
            int ret_val = open_file->seek(0, SEEK_END);
            if (ret_val != 0)
            {
                close();
                return nullptr;
            }
#else /* KLIB defined */
            pos_type ret_val {-1};
            if (::llseek(fd, 0, 0, &ret_val, SEEK_END) != 0)
            {
                close();
                return nullptr;
            }
#endif /* KLIB defined */
        }

        // If buffers have been provided by setbuf, we may need to set pointers
        // to nullptr.
        if (!reading && streambuf_type::eback() != nullptr)
            streambuf_type::setg(nullptr, nullptr, nullptr);
        if (!writing && streambuf_type::pbase() != nullptr)
            streambuf_type::setp(nullptr, nullptr, nullptr);

        // Allocate buffer. The get and put areas share the same space.
        if (reading && streambuf_type::eback() == nullptr && buffered)
        {
            char_type* temp;
            if (streambuf_type::pbase() == nullptr)
                temp = new char_type[BUFSIZ];
            else
                temp = streambuf_type::pbase();
            // We haven't read anything yet, so the end of the read buffer is
            // the same as the start.
            streambuf_type::setg(temp, temp, temp);
        }

        if (writing && streambuf_type::pbase() == nullptr && buffered)
        {
            char_type* temp;
            if (streambuf_type::eback() == nullptr)
                temp = new char_type[BUFSIZ];
            else
                temp = streambuf_type::eback();
            streambuf_type::setp(temp, temp, temp + BUFSIZ);
        }

        return this;
    }
};

/**
    Specialisation of basic_stringbuf for the simple char type.
 */
using filebuf = basic_filebuf<char>;

/**
    Specialisation of swap() for basic_filebuf. Swaps the contents and states
    of the two buffers. Calls lhs.swap(rhs).

    @param lhs, rhs Two basic_filebufs to swap.
 */
template <typename CharT, typename Traits>
void swap(basic_filebuf<CharT, Traits>& lhs, basic_filebuf<CharT, Traits>& rhs)
{
    lhs.swap(rhs);
}

#ifndef KLIB
/**
    This is the FILE class for user space, that provides C file I/O operations.
    It is a wrapper round a filebuf, which stores the file descriptor and makes
    system calls for necessary operations. Note the protected inheritance, FILE
    is supposed to be opaque and method or field accesses for it should fail. 
 */
class FILE : protected filebuf {
protected:
    // Use all the constructors of filebuf.
    using filebuf::filebuf;

    // close() goes straight to the parent filebuf.
    using filebuf::close;

    // write() needs to call the parent sputn().
    size_t write(const void* buffer, size_t size, size_t count)
    {
        return filebuf::sputn(static_cast<const char_type*>(buffer),
            size*count);
    }

    // read() needs to call the parent sgetn().
    size_t read(void* buffer, size_t size, size_t count)
    {
        return filebuf::sgetn(static_cast<char_type*>(buffer), size*count);
    }

    // flush() needs to call the parent pubsync().
    int flush() { return filebuf::pubsync(); }

    // getpos() calls the parent pubseekoff() with current and zero to return
    // the current position.
    int getpos(fpos_t* pos)
    {
        *pos = filebuf::pubseekoff(0, std::ios_base::cur);
        return (*pos == fpos_t {-1} ? -1 : 0);
    }

    // seek() needs to call the parent pubseekoff().
    int seek(long offset, int origin)
    {
        switch (origin)
        {
        case SEEK_SET:
            return filebuf::pubseekoff(offset, ios_base::beg);
        case SEEK_CUR:
            return filebuf::pubseekoff(offset, ios_base::cur);
        case SEEK_END:
            return filebuf::pubseekoff(offset, ios_base::end);
        default:
            return -1;
        }
    }

    // We need to make all the f* functions friends so they can forward to the
    // member methods.
    friend FILE* fopen(const char* filename, const char* mode);
    friend int fclose(FILE* stream);
    friend size_t fwrite(const void* buffer, size_t size, size_t count,
        FILE* stream);
    friend size_t fread(void* buffer, size_t size, size_t count, FILE* stream);
    friend int fflush(FILE* stream);
    friend int fgetpos(FILE* stream, fpos_t* pos);
    friend int fseek(FILE* stream, long offset, int origin);
    // We need to make the C library initialisation a friend so we can access
    // the special open() to wrap an existing file descriptor.
    friend void helper::initialise_standard_library();
    // The function that performs C++ standard stream initialisation needs to be
    // a friend so it can cast a FILE* to a filebuf*.
    friend ios_base::Init::Init();
};
#endif /* KLIB not defined */

/**
    This class provides a file specific output stream that interfaces with a
    basic_filebuf.
 */
template <class CharT, class Traits = char_traits<CharT>>
class basic_ofstream : public basic_ostream<CharT, Traits> {
public:
    /** Type of the character. */
    using char_type = CharT;
    /** Type of the traits. traits_type::char_type must equal char_type. */
    using traits_type = Traits;
    /** Type of an int that can represent the char. Taken from traits_type. */
    using int_type = typename traits_type::int_type;
    /** Type that can represent a position in a stream. Taken from
        traits_type. */
    using pos_type = typename traits_type::pos_type;
    /** Type of an int that can represent an offset in a stream. Taken from
        traits_type. */
    using off_type = typename traits_type::off_type;

protected:
    /** The type of the parent basic_ostream, for convenience. */
    using ostream_type = basic_ostream<char_type, traits_type>;
    /** Type of the underlying string buffer, for convenience. */
    using filebuf_type =
        basic_filebuf<char_type, traits_type>;

public:
    /**
        Default constructor. Creates a basic_filebuf not associated with any
        file and constucts the base.
     */
    basic_ofstream() : ostream_type {nullptr}, fb {new filebuf_type{}}
    {
        ostream_type::init(fb);
    }

    /**
        Constructor. Opens the file with the specified name with the specified
        mode, with the addition of ios_base::out.

        @param filename Name of the file to open.
        @param mode Mode in which to open the file.
     */
    explicit basic_ofstream(const char* filename,
        ios_base::openmode mode = ios_base::out) :
        ostream_type {nullptr},
        fb {new filebuf_type{}}
    {
        ostream_type::init(fb);
        if (fb->open(filename, mode | ios_base::out) == nullptr)
            ostream_type::setstate(ios_base::failbit);
    }

    explicit basic_ofstream(const string& filename,
        ios_base::openmode mode = ios_base::out) :
        basic_ofstream {filename.c_str(), mode}
    {}

    /**
        Non-standard constructor, in user mode only, to associate a file stream
        with an existing filebuf. Used in the initialisation of the standard
        streams.  The mode is set to ios_base::out.

        @param filebuf Existing filebuf to associate.
     */
#ifndef KLIB
    explicit basic_ofstream(filebuf_type* f) : ostream_type {nullptr}, fb {f}
    {}
#endif /* KLIB defined */

    /**
        Copy constructor is deleted.

        @param other Other ofstream to (not) copy.
     */
    basic_ofstream(const basic_ofstream& other) = delete;

    /**
        Move constructor. Pirates the state from the other ofstream. The state
        move is handled by the parent constructor. The member filebuf is also
        moved and the inherited buffer pointer is redirected. The other buffer
        pointer is set to nullptr.

        @param other Other ofstream to pirate from.
     */
    basic_ofstream(basic_ofstream&& other) :
        ostream_type {move(other)},
        fb {move(other.fb)}
    {
        other.fb = nullptr;
        ostream_type::set_rdbuf(fb);
        other.set_rdbuf(nullptr);
    }

    /**
        Move assignment. Pirates the state from the other ofstream. The state
        move is handled by the parent type. The member filebuf is also
        moved and the inherited buffer pointer is redirected. The other buffer
        pointer is set to nullptr.

        @param other Other ofstream to pirate from.
        @return This ofstream.
     */
    basic_ofstream& operator=(basic_ofstream&& other)
    {
        ostream_type::operator=(move(other));
        fb = other.fb;
        other.fb = nullptr;
        ostream_type::set_rdbuf(fb);
        other.set_rdbuf(nullptr);

        return *this;
    }

    /**
        Swaps the state and buffer of this ofstream with another. The parent
        ostream swap() method is called to swap the state and the swap()
        method of the underlying buffer is called to swap the buffers.

        @param other Other ofstream to swap with.
     */
    void swap(basic_ofstream& other)
    {
        ostream_type::swap(other);
        fb->swap(other.fb);
    }

    /**
        Returns the pointer to the underlying file buffer.

        @return Pointer to the underlying file buffer.
     */
    filebuf_type* rdbuf() const
    {
        return const_cast<filebuf_type*>(fb);
    }

    /**
        Checks whether the stream has an open associated file. Calls the member
        filebuf open() method.

        @return Whether there is an open file associated with the stream.
     */
    bool is_open() const { return fb->is_open(); }

    /**
        Calls the member filebuf open() method to open and associate a file.
        Sets the state depending on the success of the call. The file is open
        in the provided mode, with the addition of ios_base::out.

        @param filename Name of the file to open.
        @param mode Mode toopen the file in. Defaults to ios_base::out.
     */
    void open(const char* filename, ios_base::openmode mode = ios_base::out)
    {
        if (fb->open(filename, mode | ios_base::out) == nullptr)
            ostream_type::setstate(ios_base::failbit);
        else
            ostream_type::clear();
    }

    void open(const string& filename, ios_base::openmode mode = ios_base::out)
    {
        open(filename.c_str(), mode);
    }

    /**
        Calls the member filebuf close() method to flush and close the
        associated file. Sets the state to fail if the call fails.
     */
    void close()
    {
        if (fb->close() == nullptr)
            ostream_type::setstate(ios_base::failbit);
        delete fb;
        fb = nullptr;
    }

protected:
    // The basic_filebuf. The inherited buffer member pointer will be set to
    // point at this.
    filebuf_type* fb;
};

/**
    Specialisation of basic_ofstream for the simple char type.
 */
using ofstream = basic_ofstream<char>;

/**
    Specialisation of swap() for basic_ofstream. Swaps the contents and states
    of the two streams. Calls lhs.swap(rhs).

    @param lhs, rhs Two basic_ofstreams to swap.
 */
template <typename CharT, typename Traits>
void swap(basic_ofstream<CharT, Traits>& lhs,
    basic_ofstream<CharT, Traits>& rhs)
{
    lhs.swap(rhs);
}

/**
    This class provides a file specific input stream that interfaces with a
    basic_filebuf.
 */
template <class CharT, class Traits = char_traits<CharT>>
class basic_ifstream : public basic_istream<CharT, Traits> {
public:
    /** Type of the character. */
    using char_type = CharT;
    /** Type of the traits. traits_type::char_type must equal char_type. */
    using traits_type = Traits;
    /** Type of an int that can represent the char. Taken from traits_type. */
    using int_type = typename traits_type::int_type;
    /** Type that can represent a position in a stream. Taken from
        traits_type. */
    using pos_type = typename traits_type::pos_type;
    /** Type of an int that can represent an offset in a stream. Taken from
        traits_type. */
    using off_type = typename traits_type::off_type;

protected:
    /** The type of the parent basic_istream, for convenience. */
    using istream_type = basic_istream<char_type, traits_type>;
    /** Type of the underlying string buffer, for convenience. */
    using filebuf_type =
        basic_filebuf<char_type, traits_type>;

public:
    /**
        Default constructor. Creates a basic_filebuf not associated with any
        file and constucts the base.
     */
    basic_ifstream() : istream_type {nullptr}, fb {new filebuf_type{}}
    {
        istream_type::init(fb);
    }

    /**
        Constructor. Opens the file with the specified name with the specified
        mode, with the addition of ios_base::in.

        @param filename Name of the file to open.
        @param mode Mode in which to open the file.
     */
    explicit basic_ifstream(const char* filename,
        ios_base::openmode mode = ios_base::in) :
        istream_type {nullptr},
        fb {new filebuf_type{}}
    {
        istream_type::init(fb);
        if (fb->open(filename, mode | ios_base::in) == nullptr)
            istream_type::setstate(ios_base::failbit);
    }

    explicit basic_ifstream(const string& filename,
        ios_base::openmode mode = ios_base::in) :
        basic_ifstream {filename.c_str(), mode}
    {}

    /**
        Non-standard constructor, in user mode only, to associate a file stream
        with an existing filebuf. Used in the initialisation of the standard
        streams. The mode is set to ios_base::in.

        @param filebuf Existing filebuf to associate.
     */
#ifndef KLIB
    explicit basic_ifstream(filebuf_type* f) : istream_type {nullptr}, fb {f}
    {}
#endif /* KLIB defined */

    /**
        Copy constructor is deleted.

        @param other Other ifstream to (not) copy.
     */
    basic_ifstream(const basic_ifstream& other) = delete;

    /**
        Move constructor. Pirates the state from the other ifstream. The state
        move is handled by the parent constructor. The member filebuf is also
        moved and the inherited buffer pointer is redirected. The other buffer
        pointer is set to nullptr.

        @param other Other ifstream to pirate from.
     */
    basic_ifstream(basic_ifstream&& other) :
        istream_type {move(other)},
        fb {move(other.fb)}
    {
        other.fb = nullptr;
        istream_type::set_rdbuf(&fb);
        other.set_rdbuf(nullptr);
    }

    /**
        Move assignment. Pirates the state from the other ifstream. The state
        move is handled by the parent type. The member filebuf is also
        moved and the inherited buffer pointer is redirected. The other buffer
        pointer is set to nullptr.

        @param other Other ifstream to pirate from.
        @return This ifstream.
     */
    basic_ifstream& operator=(basic_ifstream&& other)
    {
        istream_type::operator=(move(other));
        fb = other.fb;
        other.fb = nullptr;
        istream_type::set_rdbuf(fb);
        other.set_rdbuf(nullptr);

        return *this;
    }

    /**
        Swaps the state and buffer of this ifstream with another. The parent
        istream swap() method is called to swap the state and the swap()
        method of the underlying buffer is called to swap the buffers.

        @param other Other ifstream to swap with.
     */
    void swap(basic_ifstream& other)
    {
        istream_type::swap(other);
        fb->swap(other.fb);
    }

    /**
        Returns the pointer to the underlying file buffer.

        @return Pointer to the underlying file buffer.
     */
    filebuf_type* rdbuf() const
    {
        return const_cast<filebuf_type*>(fb);
    }

    /**
        Checks whether the stream has an open associated file. Calls the member
        filebuf open() method.

        @return Whether there is an open file associated with the stream.
     */
    bool is_open() const { return fb->is_open(); }

    /**
        Calls the member filebuf open() method to open and associate a file.
        Sets the state depending on the success of the call. The file is open
        in the provided mode, with the addition of ios_base::in.

        @param filename Name of the file to open.
        @param mode Mode to open the file in. Defaults to ios_base::in.
     */
    void open(const char* filename, ios_base::openmode mode = ios_base::in)
    {
        if (fb->open(filename, mode | ios_base::in) == nullptr)
            istream_type::setstate(ios_base::failbit);
        else
            istream_type::clear();
    }

    void open(const string& filename, ios_base::openmode mode = ios_base::in)
    {
        open(filename.c_str(), mode);
    }

    /**
        Calls the member filebuf close() method to close the associated file.
        Sets the state to fail if the call fails.
     */
    void close()
    {
        if (fb->close() == nullptr)
            istream_type::setstate(ios_base::failbit);
        delete fb;
        fb = nullptr;
    }

protected:
    // The basic_filebuf. The inherited buffer member pointer will be set to
    // point at this.
    filebuf_type* fb;
};

/**
    Specialisation of basic_ifstream for the simple char type.
 */
using ifstream = basic_ifstream<char>;

/**
    Specialisation of swap() for basic_ifstream. Swaps the contents and states
    of the two streams. Calls lhs.swap(rhs).

    @param lhs, rhs Two basic_ifstreams to swap.
 */
template <typename CharT, typename Traits>
void swap(basic_ifstream<CharT, Traits>& lhs,
    basic_ifstream<CharT, Traits>& rhs)
{
    lhs.swap(rhs);
}

/**
    This stream inherits from basic_iostream. It is has the normal read and
    write operations.
 */
template<typename CharT, typename Traits = char_traits<CharT>>
class basic_fstream : public basic_iostream<CharT, Traits>
{
public:
    /** Type of the character. */
    using char_type = CharT;
    /** Type of the traits. traits_type::char_type must equal char_type. */
    using traits_type = Traits;
    /** Type of an int that can represent the char. Taken from traits_type. */
    using int_type = typename traits_type::int_type;
    /** Type that can represent a position in a stream. Taken from
        traits_type. */
    using pos_type = typename traits_type::pos_type;
    /** Type of an int that can represent an offset in a stream. Taken from
        traits_type. */
    using off_type = typename traits_type::off_type;
protected:
    /** The type of the parent iostream, for convenience. */
    using iostream_type = basic_iostream<CharT, Traits>;
    /** The type of the associated streambuffer, for convenience. */
    using filebuf_type = basic_filebuf<CharT, Traits>;
public:
    /**
        Constructor. Default constructs the file buffer. Does not open any
        files.
     */
    basic_fstream() : iostream_type {nullptr}, fb {new filebuf_type{}}
    {
        iostream_type::init(fb);
    }

    /**
        Constructor. Opens the file with the given name in the given mode.

        @param filename Name fo the file to open.
        @param mode Mode in which to open the file. Defualts to in and out.
     */
    explicit basic_fstream(const char* filename,
        ios_base::openmode mode = ios_base::in | ios_base::out) :
        iostream_type {nullptr}, fb {new filebuf_type{}}
    {
        iostream_type::init(fb);
        if (fb.open(filename, mode) == nullptr)
            iostream_type::setstate(ios_base::failbit);
    }

    explicit basic_fstream(const string& filename,
        ios_base::openmode mode = ios_base::in | ios_base::out) :
        basic_fstream {filename.c_str(), mode}
    {}

    /**
        Copy constructor is deleted.

        @param other Other fstream to (not) copy.
     */
    basic_fstream(const basic_fstream& other) = delete;

    /**
        Move constructor. Pirates the state from the other fstream. The state
        move is handled by the parent constructor. The member filebuf is also
        moved and the inherited buffer pointer is redirected. The other buffer
        pointer is set to nullptr.

        @param other Other fstream to pirate from.
     */
    basic_fstream(basic_fstream&& other) :
        iostream_type {move(other)},
        fb {other.fb}
    {
        iostream_type::set_rdbuf(fb);
        other.set_rdbuf(nullptr);
    }

    /**
        Move assignment. Pirates the state from the other fstream. The state
        move is handled by the parent type. The member filebuf is also
        moved and the inherited buffer pointer is redirected. The other buffer
        pointer is set to nullptr.

        @param other Other fstream to pirate from.
        @return This fstream.
     */
    basic_fstream& operator=(basic_fstream&& other)
    {
        iostream_type::operator=(move(other));
        fb = other.fb;
        other.fb = nullptr;
        iostream_type::set_rdbuf(fb);
        other.set_rdbuf(nullptr);

        return *this;
    }

    /**
        Swaps the state and buffer of this fstream with another. The parent
        iostream swap() method is called to swap the state and the swap()
        method of the underlying buffer is called to swap the buffers.

        @param other Other fstream to swap with.
     */
    void swap(basic_fstream& other)
    {
        iostream_type::swap(other);
        fb->swap(other.fb);
    }

    /**
        Returns the pointer to the underlying file buffer.

        @return Pointer to the underlying file buffer.
     */
    filebuf_type* rdbuf() const
    {
        return fb;
    }

    /**
        Checks whether the stream has an open associated file. Calls the member
        filebuf open() method.

        @return Whether there is an open file associated with the stream.
     */
    bool is_open() const { return fb->is_open(); }

    /**
        Calls the member filebuf open() method to open and associate a file.
        Sets the state depending on the success of the call. The file is open
        in the provided mode.

        @param filename Name of the file to open.
        @param mode Mode to open the file in. Defaults to in and out.
     */
    void open(const char* filename,
        ios_base::openmode mode = ios_base::in | ios_base::out)
    {
        if (fb->open(filename, mode) == nullptr)
            iostream_type::setstate(ios_base::failbit);
        else
            iostream_type::clear();
    }

    void open(const string& filename,
        ios_base::openmode mode = ios_base::in | ios_base::out)
    {
        open(filename.c_str(), mode);
    }

    /**
        Calls the member filebuf close() method to close the associated file.
        Sets the state to fail if the call fails.
     */
    void close()
    {
        if (fb->close() == nullptr)
            iostream_type::setstate(ios_base::failbit);
        delete fb;
        fb = nullptr;
    }

protected:
    // The basic_filebuf. The inherited buffer member pointer will be set to
    // point at this.
    filebuf_type* fb;
};

/**
    Specialisation of basic_fstream for the simple char type.
 */
using fstream = basic_fstream<char>;

/**
    Specialisation of swap() for basic_fstream. Swaps the contents and states of
    the two streams. Calls lhs.swap(rhs).

    @param lhs, rhs Two basic_fstreams to swap.
 */
template <typename CharT, typename Traits>
void swap(basic_fstream<CharT, Traits>& lhs, basic_fstream<CharT, Traits>& rhs)
{
    lhs.swap(rhs);
}

} // end NMSP namespace

#endif /* FSTREAM_H */
